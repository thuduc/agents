# Vulnerability Scanning Agent

Enterprise-grade vulnerability scanning system that automatically scans BitBucket repositories for Python dependencies and identifies security vulnerabilities using multiple CVE databases.

## Multi-Agent Framework (POC)

This vulnerability scanning agent represents the **first specialized sub-agent** in an ongoing proof-of-concept for a comprehensive vulnerability management ecosystem. The current implementation focuses specifically on vulnerability detection and identification, while the broader vision encompasses a **manager agent** that will orchestrate multiple specialized sub-agents to handle the complete end-to-end vulnerability resolution lifecycle.

**Planned Multi-Agent Architecture:**
- **Scanning Agent** (Current): Discovers and identifies vulnerabilities across repositories
- **Assessment Agent** (Planned): Analyzes vulnerability impact and prioritizes remediation
- **Remediation Agent** (Planned): Suggests and implements vulnerability fixes
- **Validation Agent** (Planned): Verifies successful vulnerability resolution
- **Reporting Agent** (Planned): Generates compliance and audit reports

Each sub-agent will specialize in distinct aspects of vulnerability management, coordinated by an overarching manager agent that handles workflow orchestration, inter-agent communication, and business process integration.

## Architecture

The Vulnerability Scanning Agent consists of several key components:

- **Repository Scanner**: Discovers and analyzes BitBucket repositories for dependency files
- **Multi-CVE Integration**: Scans packages against NVD, OSS Index, and Snyk databases
- **Storage Layer**: Stores scan results in DynamoDB with optimized indexing
- **Dashboard API**: Provides REST endpoints and real-time WebSocket updates
- **Notification System**: Sends alerts for critical vulnerabilities
- **Health Monitoring**: Tracks system performance and external dependencies

## Technology Stack

- **Backend**: Python 3.11+, AsyncIO
- **API Framework**: aiohttp with WebSocket support
- **Database**: AWS DynamoDB with GSI indexes
- **CVE Sources**: NIST NVD, Sonatype OSS Index, Snyk API
- **Repository Integration**: BitBucket REST API
- **Monitoring**: Health checks and metrics collection
- **Deployment**: Docker, AWS ECS/Fargate
- **Configuration**: YAML files + environment variables

## Features

### 🔍 **Comprehensive Repository Scanning**
- **BitBucket Integration**: Automatically discovers and scans all repositories in your workspace
- **Dependency Detection**: Finds `requirements.txt`, `setup.py`, and `pyproject.toml` files
- **Scheduled Scanning**: Configurable cron-based scheduling for automated daily/weekly scans
- **Concurrent Processing**: Multi-threaded scanning with configurable concurrency limits

### 🛡️ **Multi-Source Vulnerability Detection**
- **NIST NVD**: National Vulnerability Database integration with API key support
- **Sonatype OSS Index**: Free vulnerability database for open source components
- **Snyk API**: Commercial vulnerability database with advanced threat intelligence
- **Unified Results**: Aggregates and deduplicates vulnerabilities across all sources

### 💾 **Robust Data Storage**
- **DynamoDB Backend**: Scalable NoSQL storage for scan results and metadata
- **Indexed Queries**: Optimized for fast retrieval by repository, severity, and timestamp
- **Historical Tracking**: Maintains complete scan history and trend analysis
- **Auto-scaling**: Pay-per-use billing model with automatic capacity management

### 📊 **Real-time Reporting & Dashboard**
- **REST API**: Comprehensive API for integration with existing tools
- **Executive Reports**: High-level security metrics for management
- **WebSocket Updates**: Real-time vulnerability notifications
- **Security Metrics**: CVSS scores, severity distributions, and trend analysis

## Architecture

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   BitBucket     │    │   CVE Sources   │    │   DynamoDB      │
│   Repositories  │    │                 │    │   Storage       │
│                 │    │  • NVD API      │    │                 │
│  • requirements │◄───┤  • OSS Index    ├───►│  • Scan Results │
│  • setup.py     │    │  • Snyk API     │    │  • Repositories │
│  • pyproject    │    │                 │    │  • Metadata     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────────────────────────────────────────────────────┐
│                 Vulnerability Scanning Agent                    │
│                                                                 │
│  ┌───────────────┐  ┌──────────────┐  ┌────────────────────┐   │
│  │   Scheduler   │  │   Scanner    │  │     Reporter       │   │
│  │               │  │              │  │                    │   │
│  │ • Cron Jobs   │  │ • Multi-CVE  │  │ • Dashboard API    │   │
│  │ • Triggers    │  │ • Concurrent │  │ • Alerts           │   │
│  │ • Queue Mgmt  │  │ • Retry Logic│  │ • WebSocket        │   │
│  └───────────────┘  └──────────────┘  └────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
                    ┌─────────────────────┐
                    │   Dashboard API     │
                    │                     │
                    │  • REST Endpoints   │
                    │  • Real-time Updates│
                    │  • Security Reports │
                    └─────────────────────┘
```

## Quick Start

```bash
# Install dependencies
pip install -r requirements.txt

# Configure environment
cp .env.example .env
# Edit .env with your credentials

# Initialize database
python -c "import asyncio; from src.storage.dynamodb_storage import DynamoDBStorage; from src.core.models import Config; asyncio.run(DynamoDBStorage(Config()).initialize_tables())"

# Run a single scan
python main.py --scan-once

# Start the API server
python start_api.py

# Start scheduled scanning
python main.py --daemon
```

## Directory Structure

```
vulnerability-scanning-agent/
├── src/
│   ├── core/            # Core models and agent orchestrator
│   ├── scanning/        # Repository and CVE scanning engines
│   ├── storage/         # DynamoDB data layer
│   ├── dashboard/       # REST API and dashboard
│   ├── notifications/   # Alerting and reporting
│   ├── config/          # Configuration management
│   └── monitoring/      # Health checks and metrics
├── tests/               # Test suites
├── docs/                # Documentation
├── configs/             # Configuration files
├── examples/            # Usage examples
├── main.py              # CLI entry point
└── start_api.py         # API server entry point
```

## Features

- 🔍 **Automated Repository Discovery**: Scans all BitBucket repositories
- 📋 **Multi-format Support**: Handles requirements.txt, setup.py, pyproject.toml
- 🛡️ **Multi-CVE Integration**: NVD, OSS Index, Snyk databases
- 📊 **Real-time Dashboard**: REST API with WebSocket updates
- ⚡ **Concurrent Scanning**: Configurable parallel processing
- 🔄 **Scheduled Operations**: Cron-based automated scanning
- 📈 **Executive Reporting**: High-level security metrics
- 🚨 **Smart Alerting**: Critical vulnerability notifications
- 💾 **Scalable Storage**: DynamoDB with auto-scaling
- 🎯 **AWS-native Deployment**: ECS Fargate ready

```bash
# BitBucket Configuration
BITBUCKET_WORKSPACE=your-workspace
BITBUCKET_USERNAME=your-username  
BITBUCKET_APP_PASSWORD=your-app-password

# CVE Database APIs (at least one required)
NVD_API_KEY=your-nvd-api-key
SNYK_API_TOKEN=your-snyk-token
OSS_INDEX_USERNAME=your-oss-username
OSS_INDEX_TOKEN=your-oss-token

# AWS Configuration
AWS_REGION=us-east-1
DYNAMODB_TABLE_PREFIX=vuln-scanner

# Optional: Scanning Configuration
SCAN_SCHEDULE="0 2 * * *"  # Daily at 2 AM
MAX_CONCURRENT_SCANS=5
SCAN_TIMEOUT=300

# Optional: API Configuration
API_HOST=0.0.0.0
API_PORT=8080
```

### 3. Initialize Database

```bash
# Create DynamoDB tables
python -c "
import asyncio
from config_manager import ConfigManager
from vulnerability_scanning_agent import VulnerabilityScanningAgent

async def init():
    config_manager = ConfigManager()
    config = config_manager.get_config()
    agent = VulnerabilityScanningAgent(config)
    await agent.initialize()
    print('Database initialized successfully')

asyncio.run(init())
"
```

### 4. Run Initial Scan

```bash
# Perform an initial scan of all repositories
python vulnerability_scanning_agent.py
```

### 5. Start Dashboard API

```bash
# Start the dashboard API server
python vulnerability_dashboard_api.py
```

Access the dashboard at `http://localhost:8080`

## Usage Examples

### Command Line Scanning

```bash
# Run a one-time scan of all repositories
python vulnerability_scanning_agent.py

# Start the scheduled scanning service
python vulnerability_scanning_agent.py --daemon
```

### API Endpoints

#### Get Dashboard Summary
```bash
curl http://localhost:8080/api/v1/dashboard
```

#### Search Vulnerabilities
```bash
# Search by severity
curl "http://localhost:8080/api/v1/vulnerabilities/search?severity=critical"

# Search by package name
curl "http://localhost:8080/api/v1/vulnerabilities/search?package=requests"

# Search by CVE ID
curl "http://localhost:8080/api/v1/vulnerabilities/search?cve=CVE-2023-12345"
```

#### Get Repository Vulnerabilities
```bash
curl "http://localhost:8080/api/v1/repositories/my-repo/vulnerabilities"
```

#### Trigger Manual Scan
```bash
curl -X POST http://localhost:8080/api/v1/scan/trigger \
  -H "Content-Type: application/json" \
  -d '{"repository": "specific-repo-name"}'
```

### WebSocket Real-time Updates

```javascript
const ws = new WebSocket('ws://localhost:8080/ws/vulnerabilities');

ws.onmessage = function(event) {
    const data = JSON.parse(event.data);
    console.log('Vulnerability update:', data);
};
```

## Configuration

### Environment Variables

| Variable | Description | Required | Default |
|----------|-------------|----------|---------|
| `BITBUCKET_WORKSPACE` | BitBucket workspace name | Yes | - |
| `BITBUCKET_USERNAME` | BitBucket username | Yes | - |
| `BITBUCKET_APP_PASSWORD` | BitBucket app password | Yes | - |
| `NVD_API_KEY` | NIST NVD API key | No* | - |
| `SNYK_API_TOKEN` | Snyk API token | No* | - |
| `OSS_INDEX_USERNAME` | OSS Index username | No* | - |
| `OSS_INDEX_TOKEN` | OSS Index token | No* | - |
| `AWS_REGION` | AWS region for DynamoDB | No | us-east-1 |
| `DYNAMODB_TABLE_PREFIX` | DynamoDB table prefix | No | vuln-scanner |
| `SCAN_SCHEDULE` | Cron schedule for scanning | No | 0 2 * * * |
| `MAX_CONCURRENT_SCANS` | Max parallel scans | No | 5 |
| `API_PORT` | Dashboard API port | No | 8080 |

*At least one CVE source must be configured

### Configuration Files

You can also use YAML configuration files:

```yaml
# config.yaml
database:
  region: us-east-1
  table_prefix: vuln-scanner

bitbucket:
  workspace: your-workspace
  username: your-username
  app_password: your-app-password

cve_sources:
  nvd_api_key: your-nvd-key
  snyk_api_token: your-snyk-token

scanning:
  schedule: "0 2 * * *"
  max_concurrent_scans: 10
  scan_timeout: 600

alerts:
  enabled: true
  critical_threshold: 1
  email_recipients:
    - security@company.com
  slack_webhook_url: https://hooks.slack.com/...

api:
  host: 0.0.0.0
  port: 8080
  cors_origins: ['https://dashboard.company.com']
```

## API Reference

### Dashboard Endpoints

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/v1/dashboard` | GET | Get dashboard summary |
| `/api/v1/repositories` | GET | List all repositories |
| `/api/v1/repositories/{repo}/vulnerabilities` | GET | Get repo vulnerabilities |
| `/api/v1/vulnerabilities/search` | GET | Search vulnerabilities |
| `/api/v1/vulnerabilities/trending` | GET | Get trending vulnerabilities |
| `/api/v1/reports/executive` | GET | Executive security report |
| `/api/v1/metrics` | GET | Security metrics |
| `/api/v1/scan/trigger` | POST | Trigger manual scan |
| `/api/v1/scan/status` | GET | Get scan status |
| `/ws/vulnerabilities` | WebSocket | Real-time updates |

### Response Format

All API responses follow this format:

```json
{
  "status": "success|error",
  "data": {...},
  "message": "Optional message",
  "timestamp": "2024-01-15T10:30:00Z"
}
```

### Vulnerability Object Schema

```json
{
  "cve_id": "CVE-2023-12345",
  "package_name": "requests",
  "affected_version": "2.25.1",
  "severity": "HIGH",
  "description": "Vulnerability description",
  "cvss_score": 7.5,
  "published_date": "2023-01-15T10:30:00Z",
  "references": ["https://..."],
  "source": "NVD|OSS_INDEX|SNYK",
  "repository": "my-repo",
  "scan_timestamp": "2024-01-15T10:30:00Z"
}
```

## Deployment

### Docker Deployment

```dockerfile
FROM python:3.11-slim

WORKDIR /app
COPY . .
RUN pip install -r requirements.txt

EXPOSE 8080
CMD ["python", "vulnerability_dashboard_api.py"]
```

### AWS ECS Deployment

```yaml
# docker-compose.yml
version: '3.8'
services:
  vulnerability-scanner:
    build: .
    environment:
      - AWS_REGION=us-east-1
      - BITBUCKET_WORKSPACE=${BITBUCKET_WORKSPACE}
      - BITBUCKET_USERNAME=${BITBUCKET_USERNAME}
      - BITBUCKET_APP_PASSWORD=${BITBUCKET_APP_PASSWORD}
    ports:
      - "8080:8080"
    restart: unless-stopped
```

### Kubernetes Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: vulnerability-scanner
spec:
  replicas: 2
  selector:
    matchLabels:
      app: vulnerability-scanner
  template:
    metadata:
      labels:
        app: vulnerability-scanner
    spec:
      containers:
      - name: scanner
        image: vulnerability-scanner:latest
        ports:
        - containerPort: 8080
        env:
        - name: AWS_REGION
          value: "us-east-1"
        - name: BITBUCKET_WORKSPACE
          valueFrom:
            secretKeyRef:
              name: scanner-secrets
              key: bitbucket-workspace
```

## Monitoring and Alerting

### Metrics Collection

The system exposes metrics for monitoring:

- Total vulnerabilities found
- Scan duration and success rate  
- API response times
- Database query performance
- Memory and CPU usage

### Integration with Monitoring Systems

```python
# Example: Prometheus metrics integration
from prometheus_client import Counter, Histogram, Gauge

vulnerabilities_found = Counter('vulnerabilities_total', 'Total vulnerabilities found', ['severity'])
scan_duration = Histogram('scan_duration_seconds', 'Scan duration')
active_scans = Gauge('active_scans', 'Number of active scans')
```

### Alerting Rules

Configure alerts for:
- Critical vulnerabilities discovered
- Scan failures
- API service downtime
- Database connectivity issues
- High memory usage

## Security Considerations

### Credential Management
- Use AWS IAM roles instead of access keys when possible
- Store sensitive credentials in AWS Secrets Manager
- Rotate API keys regularly
- Use least-privilege access principles

### Network Security
- Run API server behind a reverse proxy (nginx, ALB)
- Enable HTTPS/TLS encryption
- Configure CORS origins appropriately
- Implement rate limiting and authentication

### Data Protection
- Encrypt DynamoDB tables at rest
- Enable VPC endpoints for AWS services
- Audit and log all API access
- Implement data retention policies

## Testing

### Run All Tests
```bash
# Install test dependencies
pip install pytest pytest-asyncio pytest-mock moto

# Run the complete test suite
pytest test_vulnerability_scanner.py -v

# Run tests with coverage
pytest test_vulnerability_scanner.py -v --cov=. --cov-report=term-missing
```

### Test Categories
- **Unit Tests**: Individual component testing
- **Integration Tests**: End-to-end workflow testing
- **API Tests**: REST endpoint testing
- **Performance Tests**: Load and concurrency testing

## Troubleshooting

### Common Issues

#### BitBucket Authentication Failures
```bash
# Test BitBucket credentials
curl -u username:app_password \
  https://api.bitbucket.org/2.0/repositories/workspace
```

#### DynamoDB Access Issues
```bash
# Test AWS credentials
aws dynamodb list-tables --region us-east-1
```

#### CVE API Rate Limits
- NVD: 50 requests per 30 seconds (without API key), 50 per 30 seconds (with key)
- OSS Index: 128 coordinates per request, rate limits apply
- Snyk: Varies by subscription plan

### Logging

Enable debug logging:
```bash
export LOG_LEVEL=DEBUG
python vulnerability_scanning_agent.py
```

### Performance Tuning

- Adjust `MAX_CONCURRENT_SCANS` based on available resources
- Increase `SCAN_TIMEOUT` for large repositories
- Use DynamoDB auto-scaling for high-volume deployments
- Implement caching for frequently accessed data

## Contributing

### Development Setup

```bash
# Install development dependencies
pip install -r requirements.txt

# Run tests
pytest test_vulnerability_scanner.py

# Code formatting
black *.py
isort *.py

# Type checking
mypy *.py

# Security scanning
bandit -r .
safety check
```

### Adding New CVE Sources

1. Implement scanner class inheriting from base CVE scanner
2. Add configuration options to `config_manager.py`
3. Update the `MultiCVEScanner` class
4. Add tests for the new integration
5. Update documentation

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Support

For support and questions:
- Create an issue in the repository
- Check the troubleshooting section
- Review the API documentation
- Contact the security team

---

## PoC Assessment

**Development Velocity**: These agents were built in hours, not months. What traditionally takes a team weeks to develop - complete with testing, documentation, and deployment configurations - was delivered as production-ready code in a single session. The Monthly Runbook Agent automates complex operational workflows, while the Vulnerability Scanner creates an enterprise security platform with real-time dashboards.

**LLM Capabilities**: Claude Code and Claude 4 LLMs can get us 90-95% of the way to production-ready systems, handling complex architectural decisions, implementing industry best practices, and generating comprehensive test suites that would typically require senior engineering expertise across multiple domains.

**Production Readiness Gap**: The remaining 5-10% involves environment-specific configurations, security hardening for production data, integration with existing enterprise systems, and performance optimization under real-world loads - tasks that require domain expertise but benefit significantly from the AI-generated foundation.


**⚠️ Security Notice**: This tool is designed for defensive security purposes only. Use responsibly and in accordance with your organization's security policies.