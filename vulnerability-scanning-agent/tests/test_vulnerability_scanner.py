#!/usr/bin/env python3
"""
Test Suite for Vulnerability Scanning Agent
Comprehensive tests for all components of the vulnerability scanning system
"""

import pytest
import asyncio
import json
from datetime import datetime, timedelta
from unittest.mock import Mock, AsyncMock, patch, MagicMock
from aiohttp.test_utils import AioHTTPTestCase, unittest_run_loop
from aiohttp import web
import boto3
from moto import mock_dynamodb

from vulnerability_scanning_agent import (
    VulnerabilityScanningAgent, BitBucketScanner, MultiCVEScanner,
    DynamoDBStorage, VulnerabilityReporter, Config, Vulnerability, SeverityLevel
)
from vulnerability_dashboard_api import VulnerabilityDashboardAPI
from config_manager import ConfigManager, AppConfig

class TestConfig:
    """Test configuration setup"""
    
    @pytest.fixture
    def test_config(self):
        """Create test configuration"""
        return Config(
            bitbucket_workspace='test-workspace',
            bitbucket_username='test-user',
            bitbucket_app_password='test-password',
            nvd_api_key='test-nvd-key',
            snyk_api_token='test-snyk-token',
            oss_index_username='test-oss-user',
            oss_index_token='test-oss-token',
            dynamodb_region='us-east-1',
            dynamodb_table_prefix='test-vuln-scanner'
        )

class TestBitBucketScanner:
    """Test BitBucket repository scanning functionality"""
    
    @pytest.fixture
    def mock_session(self):
        """Mock aiohttp session"""
        session = AsyncMock()
        return session
    
    @pytest.mark.asyncio
    async def test_get_repositories(self, test_config, mock_session):
        """Test repository discovery"""
        # Mock repository response
        mock_response = AsyncMock()
        mock_response.status = 200
        mock_response.json.return_value = {
            'values': [
                {'name': 'repo1', 'full_name': 'workspace/repo1'},
                {'name': 'repo2', 'full_name': 'workspace/repo2'}
            ],
            'next': None
        }
        mock_session.get.return_value.__aenter__.return_value = mock_response
        
        scanner = BitBucketScanner(test_config)
        scanner.session = mock_session
        
        repositories = await scanner.get_repositories()
        
        assert len(repositories) == 2
        assert repositories[0]['name'] == 'repo1'
        assert repositories[1]['name'] == 'repo2'
    
    @pytest.mark.asyncio
    async def test_find_dependency_files(self, test_config, mock_session):
        """Test dependency file discovery"""
        # Mock file content responses
        requirements_response = AsyncMock()
        requirements_response.status = 200
        requirements_response.text.return_value = "requests==2.25.1\nflask==1.1.1"
        
        setup_response = AsyncMock()
        setup_response.status = 404  # setup.py not found
        
        mock_session.get.side_effect = [
            requirements_response.__aenter__().__await__(),
            setup_response.__aenter__().__await__()
        ]
        
        scanner = BitBucketScanner(test_config)
        scanner.session = mock_session
        
        dependency_files = await scanner.find_dependency_files('test-repo')
        
        assert len(dependency_files) >= 1
        assert 'requirements.txt' in dependency_files[0]['file_path']
        assert 'requests==2.25.1' in dependency_files[0]['content']

class TestMultiCVEScanner:
    """Test CVE database integration"""
    
    @pytest.fixture
    def sample_vulnerability(self):
        """Create sample vulnerability for testing"""
        return Vulnerability(
            cve_id='CVE-2023-12345',
            package_name='requests',
            affected_version='2.25.1',
            severity=SeverityLevel.HIGH,
            description='Test vulnerability',
            cvss_score=7.5,
            published_date=datetime.now(),
            references=['https://example.com/vuln'],
            source='TEST'
        )
    
    @pytest.mark.asyncio
    async def test_scan_package(self, test_config):
        """Test package vulnerability scanning"""
        scanner = MultiCVEScanner(test_config)
        scanner.session = AsyncMock()
        
        # Mock individual scanner methods
        scanner._scan_nvd = AsyncMock(return_value=[])
        scanner._scan_oss_index = AsyncMock(return_value=[])
        scanner._scan_snyk = AsyncMock(return_value=[])
        
        vulnerabilities = await scanner.scan_package('requests', '2.25.1')
        
        assert isinstance(vulnerabilities, list)
        scanner._scan_nvd.assert_called_once_with('requests', '2.25.1')
        scanner._scan_oss_index.assert_called_once_with('requests', '2.25.1')
        scanner._scan_snyk.assert_called_once_with('requests', '2.25.1')
    
    @pytest.mark.asyncio
    async def test_nvd_scanning(self, test_config):
        """Test NVD API integration"""
        mock_response = AsyncMock()
        mock_response.status = 200
        mock_response.json.return_value = {
            'vulnerabilities': [
                {
                    'cve': {
                        'id': 'CVE-2023-12345',
                        'descriptions': [{'value': 'Test vulnerability'}],
                        'published': '2023-01-15T10:30:00.000Z',
                        'references': [{'url': 'https://example.com'}],
                        'metrics': {
                            'cvssMetricV31': [
                                {'cvssData': {'baseScore': 7.5}}
                            ]
                        }
                    }
                }
            ]
        }
        
        scanner = MultiCVEScanner(test_config)
        scanner.session = AsyncMock()
        scanner.session.get.return_value.__aenter__.return_value = mock_response
        
        vulnerabilities = await scanner._scan_nvd('requests', '2.25.1')
        
        assert len(vulnerabilities) == 1
        assert vulnerabilities[0].cve_id == 'CVE-2023-12345'
        assert vulnerabilities[0].cvss_score == 7.5
        assert vulnerabilities[0].source == 'NVD'
    
    def test_severity_from_cvss(self, test_config):
        """Test CVSS to severity conversion"""
        scanner = MultiCVEScanner(test_config)
        
        assert scanner._get_severity_from_cvss(9.5) == SeverityLevel.CRITICAL
        assert scanner._get_severity_from_cvss(7.5) == SeverityLevel.HIGH
        assert scanner._get_severity_from_cvss(5.0) == SeverityLevel.MEDIUM
        assert scanner._get_severity_from_cvss(2.0) == SeverityLevel.LOW
        assert scanner._get_severity_from_cvss(0.0) == SeverityLevel.INFO

@mock_dynamodb
class TestDynamoDBStorage:
    """Test DynamoDB storage functionality"""
    
    @pytest.fixture
    def mock_dynamodb(self):
        """Setup mock DynamoDB"""
        with mock_dynamodb():
            yield boto3.resource('dynamodb', region_name='us-east-1')
    
    @pytest.mark.asyncio
    async def test_initialize_tables(self, test_config, mock_dynamodb):
        """Test DynamoDB table creation"""
        storage = DynamoDBStorage(test_config)
        storage.dynamodb = mock_dynamodb
        
        await storage.initialize_tables()
        
        # Check tables were created
        tables = list(mock_dynamodb.tables.all())
        table_names = [table.name for table in tables]
        
        assert f"{test_config.dynamodb_table_prefix}-scan-results" in table_names
        assert f"{test_config.dynamodb_table_prefix}-repositories" in table_names
    
    @pytest.mark.asyncio
    async def test_store_scan_results(self, test_config, mock_dynamodb, sample_vulnerability):
        """Test storing scan results"""
        storage = DynamoDBStorage(test_config)
        storage.dynamodb = mock_dynamodb
        
        await storage.initialize_tables()
        
        vulnerabilities = [sample_vulnerability]
        await storage.store_scan_results('test-scan-id', 'test-repo', vulnerabilities)
        
        # Verify data was stored
        table = mock_dynamodb.Table(f"{test_config.dynamodb_table_prefix}-scan-results")
        response = table.scan()
        
        assert response['Count'] == 1
        item = response['Items'][0]
        assert item['scan_id'] == 'test-scan-id'
        assert item['repository'] == 'test-repo'
        assert item['cve_id'] == 'CVE-2023-12345'

class TestVulnerabilityScanningAgent:
    """Test main scanning agent functionality"""
    
    @pytest.mark.asyncio
    async def test_agent_initialization(self, test_config):
        """Test agent initialization"""
        agent = VulnerabilityScanningAgent(test_config)
        
        # Mock storage initialization
        agent.storage.initialize_tables = AsyncMock()
        
        await agent.initialize()
        
        agent.storage.initialize_tables.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_scan_all_repositories(self, test_config):
        """Test comprehensive repository scanning"""
        agent = VulnerabilityScanningAgent(test_config)
        
        # Mock dependencies
        agent.storage.initialize_tables = AsyncMock()
        agent.storage.store_scan_results = AsyncMock()
        agent.reporter.send_critical_alerts = AsyncMock()
        
        with patch('vulnerability_scanning_agent.BitBucketScanner') as mock_scanner_class:
            mock_scanner = AsyncMock()
            mock_scanner_class.return_value.__aenter__.return_value = mock_scanner
            
            # Mock repository discovery
            mock_scanner.get_repositories.return_value = [
                {'name': 'repo1'},
                {'name': 'repo2'}
            ]
            
            # Mock the scanning method
            agent._scan_repository_with_semaphore = AsyncMock(return_value=[])
            
            results = await agent.scan_all_repositories()
            
            assert 'repo1' in results
            assert 'repo2' in results
    
    def test_parse_dependencies(self, test_config):
        """Test dependency parsing from requirements files"""
        agent = VulnerabilityScanningAgent(test_config)
        
        requirements_content = """
        requests==2.25.1
        flask>=1.1.0
        django
        # This is a comment
        pytest==6.2.0
        """
        
        packages = agent._parse_dependencies(requirements_content)
        
        assert ('requests', '2.25.1') in packages
        assert ('flask', 'latest') in packages
        assert ('django', 'latest') in packages
        assert ('pytest', '6.2.0') in packages
        assert len(packages) == 4  # Comments should be ignored

class TestVulnerabilityDashboardAPI(AioHTTPTestCase):
    """Test dashboard API endpoints"""
    
    async def get_application(self):
        """Setup test application"""
        test_config = Config(
            dynamodb_table_prefix='test-vuln-scanner',
            dynamodb_region='us-east-1'
        )
        
        dashboard = VulnerabilityDashboardAPI(test_config)
        
        # Mock storage
        dashboard.storage = Mock()
        dashboard.storage.dynamodb = Mock()
        
        return dashboard.app
    
    @unittest_run_loop
    async def test_dashboard_summary(self):
        """Test dashboard summary endpoint"""
        # Mock DynamoDB table
        mock_table = Mock()
        mock_table.scan.return_value = {
            'Items': [
                {
                    'severity': 'CRITICAL',
                    'repository': 'repo1',
                    'scan_timestamp': datetime.now().isoformat(),
                    'cve_id': 'CVE-2023-12345'
                },
                {
                    'severity': 'HIGH',
                    'repository': 'repo2',
                    'scan_timestamp': datetime.now().isoformat(),
                    'cve_id': 'CVE-2023-12346'
                }
            ]
        }
        
        self.app['dashboard'].storage.dynamodb.Table.return_value = mock_table
        
        resp = await self.client.request("GET", "/api/v1/dashboard")
        
        assert resp.status == 200
        data = await resp.json()
        
        assert 'total_vulnerabilities' in data
        assert 'severity_breakdown' in data
        assert data['severity_breakdown']['critical'] >= 0
    
    @unittest_run_loop
    async def test_search_vulnerabilities(self):
        """Test vulnerability search endpoint"""
        # Mock DynamoDB table
        mock_table = Mock()
        mock_table.scan.return_value = {
            'Items': [
                {
                    'cve_id': 'CVE-2023-12345',
                    'package_name': 'requests',
                    'severity': 'HIGH',
                    'description': 'Test vulnerability'
                }
            ]
        }
        
        self.app['dashboard'].storage.dynamodb.Table.return_value = mock_table
        
        resp = await self.client.request("GET", "/api/v1/vulnerabilities/search?severity=high&package=requests")
        
        assert resp.status == 200
        data = await resp.json()
        
        assert 'vulnerabilities' in data
        assert 'query' in data

class TestConfigManager:
    """Test configuration management"""
    
    def test_config_loading_from_env(self, monkeypatch):
        """Test loading configuration from environment variables"""
        # Set environment variables
        monkeypatch.setenv('BITBUCKET_WORKSPACE', 'test-workspace')
        monkeypatch.setenv('NVD_API_KEY', 'test-key')
        monkeypatch.setenv('MAX_CONCURRENT_SCANS', '10')
        
        config_manager = ConfigManager()
        config = config_manager.get_config()
        
        assert config.bitbucket.workspace == 'test-workspace'
        assert config.cve_sources.nvd_api_key == 'test-key'
        assert config.scanning.max_concurrent_scans == 10
    
    def test_config_validation(self):
        """Test configuration validation"""
        config_manager = ConfigManager()
        
        # Test with invalid configuration
        config_manager.config.bitbucket.workspace = ''
        config_manager.config.cve_sources.nvd_api_key = ''
        config_manager.config.cve_sources.oss_index_token = ''
        config_manager.config.cve_sources.snyk_api_token = ''
        
        with pytest.raises(ValueError):
            config_manager._validate_config()
    
    def test_config_merging(self):
        """Test configuration merging from multiple sources"""
        config_manager = ConfigManager()
        
        # Test merging configuration
        new_config = {
            'scanning': {
                'max_concurrent_scans': 15,
                'scan_timeout': 600
            },
            'api': {
                'port': 9090
            }
        }
        
        config_manager._merge_config(new_config)
        
        assert config_manager.config.scanning.max_concurrent_scans == 15
        assert config_manager.config.scanning.scan_timeout == 600
        assert config_manager.config.api.port == 9090

class TestIntegration:
    """Integration tests for the complete system"""
    
    @pytest.mark.asyncio
    async def test_end_to_end_scan(self, test_config):
        """Test end-to-end scanning workflow"""
        # This would be a comprehensive test that mocks all external services
        # and tests the complete scanning workflow
        pass
    
    @pytest.mark.asyncio
    async def test_error_handling(self, test_config):
        """Test error handling and recovery"""
        agent = VulnerabilityScanningAgent(test_config)
        
        # Test handling of BitBucket API failures
        with patch('vulnerability_scanning_agent.BitBucketScanner') as mock_scanner:
            mock_scanner.side_effect = Exception("API Error")
            
            # Should handle error gracefully
            results = await agent.scan_all_repositories()
            assert isinstance(results, dict)

class TestPerformance:
    """Performance and load tests"""
    
    @pytest.mark.asyncio
    async def test_concurrent_scanning(self, test_config):
        """Test concurrent scanning performance"""
        # Test that the system can handle multiple concurrent scans
        # without exceeding resource limits
        pass
    
    @pytest.mark.asyncio 
    async def test_large_repository_handling(self, test_config):
        """Test handling of repositories with many dependencies"""
        # Test scanning repositories with hundreds of dependencies
        pass

# Pytest configuration
@pytest.fixture(scope="session")
def event_loop():
    """Create an instance of the default event loop for the test session"""
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()

# Test data fixtures
@pytest.fixture
def sample_vulnerability():
    """Create sample vulnerability for testing"""
    return Vulnerability(
        cve_id='CVE-2023-12345',
        package_name='requests',
        affected_version='2.25.1',
        severity=SeverityLevel.HIGH,
        description='Test vulnerability description',
        cvss_score=7.5,
        published_date=datetime.now(),
        references=['https://example.com/vuln'],
        source='TEST'
    )

@pytest.fixture
def sample_repositories():
    """Sample repository data"""
    return [
        {
            'name': 'web-app',
            'full_name': 'company/web-app',
            'language': 'python'
        },
        {
            'name': 'api-service',
            'full_name': 'company/api-service', 
            'language': 'python'
        }
    ]

if __name__ == "__main__":
    # Run tests
    pytest.main([__file__, "-v", "--tb=short"])