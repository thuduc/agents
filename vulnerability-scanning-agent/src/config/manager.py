#!/usr/bin/env python3
"""
Configuration Management System
Handles configuration loading, validation, and environment-based settings
"""

import os
import json
import logging
from dataclasses import dataclass, field
from typing import Dict, Any, Optional, List
from pathlib import Path
import yaml
from dotenv import load_dotenv

@dataclass
class DatabaseConfig:
    """Database configuration settings"""
    region: str = 'us-east-1'
    table_prefix: str = 'vuln-scanner'
    endpoint_url: Optional[str] = None  # For local DynamoDB
    
@dataclass
class BitBucketConfig:
    """BitBucket API configuration"""
    workspace: str = ''
    username: str = ''
    app_password: str = ''
    base_url: str = 'https://api.bitbucket.org/2.0'
    
@dataclass
class CVESourceConfig:
    """CVE database source configuration"""
    nvd_api_key: str = ''
    snyk_api_token: str = ''
    oss_index_username: str = ''
    oss_index_token: str = ''
    
@dataclass
class ScanConfig:
    """Scanning behavior configuration"""
    schedule: str = '0 2 * * *'  # Cron format
    max_concurrent_scans: int = 5
    scan_timeout: int = 300  # seconds
    retry_attempts: int = 3
    retry_delay: int = 60  # seconds
    
@dataclass
class AlertConfig:
    """Alerting and notification configuration"""
    enabled: bool = True
    critical_threshold: int = 1  # Alert if >= this many critical vulns
    email_recipients: List[str] = field(default_factory=list)
    slack_webhook_url: str = ''
    teams_webhook_url: str = ''
    
@dataclass
class APIConfig:
    """API server configuration"""
    host: str = '0.0.0.0'
    port: int = 8080
    cors_origins: List[str] = field(default_factory=lambda: ['*'])
    rate_limit_enabled: bool = True
    rate_limit_requests: int = 100  # per minute
    
@dataclass
class LoggingConfig:
    """Logging configuration"""
    level: str = 'INFO'
    format: str = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    file_path: Optional[str] = None
    max_file_size: int = 10485760  # 10MB
    backup_count: int = 5
    
@dataclass
class AppConfig:
    """Main application configuration"""
    database: DatabaseConfig = field(default_factory=DatabaseConfig)
    bitbucket: BitBucketConfig = field(default_factory=BitBucketConfig)
    cve_sources: CVESourceConfig = field(default_factory=CVESourceConfig)
    scanning: ScanConfig = field(default_factory=ScanConfig)
    alerts: AlertConfig = field(default_factory=AlertConfig)
    api: APIConfig = field(default_factory=APIConfig)
    logging: LoggingConfig = field(default_factory=LoggingConfig)
    
    # Environment-specific settings
    environment: str = 'development'
    debug: bool = False

class ConfigManager:
    """Manages application configuration from multiple sources"""
    
    def __init__(self, config_dir: Optional[str] = None):
        self.config_dir = Path(config_dir or os.getcwd())
        self.config = AppConfig()
        self._load_configuration()
    
    def _load_configuration(self):
        """Load configuration from multiple sources in priority order"""
        # 1. Load from environment variables
        load_dotenv()
        self._load_from_env()
        
        # 2. Load from YAML config file
        config_file = self.config_dir / 'config.yaml'
        if config_file.exists():
            self._load_from_yaml(config_file)
        
        # 3. Load from JSON config file (higher priority than YAML)
        json_config_file = self.config_dir / 'config.json'
        if json_config_file.exists():
            self._load_from_json(json_config_file)
        
        # 4. Load environment-specific overrides
        env_config_file = self.config_dir / f'config.{self.config.environment}.yaml'
        if env_config_file.exists():
            self._load_from_yaml(env_config_file)
        
        # 5. Validate configuration
        self._validate_config()
        
    def _load_from_env(self):
        """Load configuration from environment variables"""
        # Database configuration
        if os.getenv('AWS_REGION'):
            self.config.database.region = os.getenv('AWS_REGION')
        if os.getenv('DYNAMODB_TABLE_PREFIX'):
            self.config.database.table_prefix = os.getenv('DYNAMODB_TABLE_PREFIX')
        if os.getenv('DYNAMODB_ENDPOINT_URL'):
            self.config.database.endpoint_url = os.getenv('DYNAMODB_ENDPOINT_URL')
        
        # BitBucket configuration
        if os.getenv('BITBUCKET_WORKSPACE'):
            self.config.bitbucket.workspace = os.getenv('BITBUCKET_WORKSPACE')
        if os.getenv('BITBUCKET_USERNAME'):
            self.config.bitbucket.username = os.getenv('BITBUCKET_USERNAME')
        if os.getenv('BITBUCKET_APP_PASSWORD'):
            self.config.bitbucket.app_password = os.getenv('BITBUCKET_APP_PASSWORD')
        
        # CVE sources configuration
        if os.getenv('NVD_API_KEY'):
            self.config.cve_sources.nvd_api_key = os.getenv('NVD_API_KEY')
        if os.getenv('SNYK_API_TOKEN'):
            self.config.cve_sources.snyk_api_token = os.getenv('SNYK_API_TOKEN')
        if os.getenv('OSS_INDEX_USERNAME'):
            self.config.cve_sources.oss_index_username = os.getenv('OSS_INDEX_USERNAME')
        if os.getenv('OSS_INDEX_TOKEN'):
            self.config.cve_sources.oss_index_token = os.getenv('OSS_INDEX_TOKEN')
        
        # Scanning configuration
        if os.getenv('SCAN_SCHEDULE'):
            self.config.scanning.schedule = os.getenv('SCAN_SCHEDULE')
        if os.getenv('MAX_CONCURRENT_SCANS'):
            self.config.scanning.max_concurrent_scans = int(os.getenv('MAX_CONCURRENT_SCANS'))
        if os.getenv('SCAN_TIMEOUT'):
            self.config.scanning.scan_timeout = int(os.getenv('SCAN_TIMEOUT'))
        
        # API configuration
        if os.getenv('API_HOST'):
            self.config.api.host = os.getenv('API_HOST')
        if os.getenv('API_PORT'):
            self.config.api.port = int(os.getenv('API_PORT'))
        
        # General configuration
        if os.getenv('ENVIRONMENT'):
            self.config.environment = os.getenv('ENVIRONMENT')
        if os.getenv('DEBUG'):
            self.config.debug = os.getenv('DEBUG').lower() in ('true', '1', 'yes')
        
        # Logging configuration
        if os.getenv('LOG_LEVEL'):
            self.config.logging.level = os.getenv('LOG_LEVEL')
        if os.getenv('LOG_FILE'):
            self.config.logging.file_path = os.getenv('LOG_FILE')
    
    def _load_from_yaml(self, config_file: Path):
        """Load configuration from YAML file"""
        try:
            with open(config_file, 'r') as f:
                yaml_config = yaml.safe_load(f)
            
            if yaml_config:
                self._merge_config(yaml_config)
                logging.info(f"Loaded configuration from {config_file}")
                
        except Exception as e:
            logging.warning(f"Failed to load YAML config from {config_file}: {e}")
    
    def _load_from_json(self, config_file: Path):
        """Load configuration from JSON file"""
        try:
            with open(config_file, 'r') as f:
                json_config = json.load(f)
            
            if json_config:
                self._merge_config(json_config)
                logging.info(f"Loaded configuration from {config_file}")
                
        except Exception as e:
            logging.warning(f"Failed to load JSON config from {config_file}: {e}")
    
    def _merge_config(self, new_config: Dict[str, Any]):
        """Merge new configuration into existing config"""
        def merge_dicts(base_dict, new_dict):
            for key, value in new_dict.items():
                if key in base_dict and isinstance(base_dict[key], dict) and isinstance(value, dict):
                    merge_dicts(base_dict[key], value)
                else:
                    base_dict[key] = value
        
        # Convert config to dict, merge, then convert back
        config_dict = self._config_to_dict(self.config)
        merge_dicts(config_dict, new_config)
        self.config = self._dict_to_config(config_dict)
    
    def _config_to_dict(self, config: AppConfig) -> Dict[str, Any]:
        """Convert config dataclass to dictionary"""
        return {
            'database': {
                'region': config.database.region,
                'table_prefix': config.database.table_prefix,
                'endpoint_url': config.database.endpoint_url
            },
            'bitbucket': {
                'workspace': config.bitbucket.workspace,
                'username': config.bitbucket.username,
                'app_password': config.bitbucket.app_password,
                'base_url': config.bitbucket.base_url
            },
            'cve_sources': {
                'nvd_api_key': config.cve_sources.nvd_api_key,
                'snyk_api_token': config.cve_sources.snyk_api_token,
                'oss_index_username': config.cve_sources.oss_index_username,
                'oss_index_token': config.cve_sources.oss_index_token
            },
            'scanning': {
                'schedule': config.scanning.schedule,
                'max_concurrent_scans': config.scanning.max_concurrent_scans,
                'scan_timeout': config.scanning.scan_timeout,
                'retry_attempts': config.scanning.retry_attempts,
                'retry_delay': config.scanning.retry_delay
            },
            'alerts': {
                'enabled': config.alerts.enabled,
                'critical_threshold': config.alerts.critical_threshold,
                'email_recipients': config.alerts.email_recipients,
                'slack_webhook_url': config.alerts.slack_webhook_url,
                'teams_webhook_url': config.alerts.teams_webhook_url
            },
            'api': {
                'host': config.api.host,
                'port': config.api.port,
                'cors_origins': config.api.cors_origins,
                'rate_limit_enabled': config.api.rate_limit_enabled,
                'rate_limit_requests': config.api.rate_limit_requests
            },
            'logging': {
                'level': config.logging.level,
                'format': config.logging.format,
                'file_path': config.logging.file_path,
                'max_file_size': config.logging.max_file_size,
                'backup_count': config.logging.backup_count
            },
            'environment': config.environment,
            'debug': config.debug
        }
    
    def _dict_to_config(self, config_dict: Dict[str, Any]) -> AppConfig:
        """Convert dictionary to config dataclass"""
        return AppConfig(
            database=DatabaseConfig(**config_dict.get('database', {})),
            bitbucket=BitBucketConfig(**config_dict.get('bitbucket', {})),
            cve_sources=CVESourceConfig(**config_dict.get('cve_sources', {})),
            scanning=ScanConfig(**config_dict.get('scanning', {})),
            alerts=AlertConfig(**config_dict.get('alerts', {})),
            api=APIConfig(**config_dict.get('api', {})),
            logging=LoggingConfig(**config_dict.get('logging', {})),
            environment=config_dict.get('environment', 'development'),
            debug=config_dict.get('debug', False)
        )
    
    def _validate_config(self):
        """Validate configuration settings"""
        errors = []
        
        # Validate required BitBucket settings
        if not self.config.bitbucket.workspace:
            errors.append("BitBucket workspace is required")
        if not self.config.bitbucket.username:
            errors.append("BitBucket username is required")
        if not self.config.bitbucket.app_password:
            errors.append("BitBucket app password is required")
        
        # Validate at least one CVE source is configured
        if not any([
            self.config.cve_sources.nvd_api_key,
            self.config.cve_sources.oss_index_token,
            self.config.cve_sources.snyk_api_token
        ]):
            errors.append("At least one CVE source must be configured")
        
        # Validate scan settings
        if self.config.scanning.max_concurrent_scans < 1:
            errors.append("max_concurrent_scans must be at least 1")
        if self.config.scanning.scan_timeout < 60:
            errors.append("scan_timeout must be at least 60 seconds")
        
        # Validate API settings
        if not (1 <= self.config.api.port <= 65535):
            errors.append("API port must be between 1 and 65535")
        
        if errors:
            error_msg = "Configuration validation failed:\n" + "\n".join(f"  - {error}" for error in errors)
            raise ValueError(error_msg)
        
        logging.info("Configuration validation passed")
    
    def get_config(self) -> AppConfig:
        """Get the current configuration"""
        return self.config
    
    def save_config(self, config_file: Optional[Path] = None):
        """Save current configuration to file"""
        if not config_file:
            config_file = self.config_dir / 'config.yaml'
        
        config_dict = self._config_to_dict(self.config)
        
        try:
            with open(config_file, 'w') as f:
                yaml.dump(config_dict, f, default_flow_style=False, indent=2)
            logging.info(f"Configuration saved to {config_file}")
        except Exception as e:
            logging.error(f"Failed to save configuration to {config_file}: {e}")
    
    def setup_logging(self):
        """Setup logging based on configuration"""
        log_config = self.config.logging
        
        # Create formatter
        formatter = logging.Formatter(log_config.format)
        
        # Setup root logger
        root_logger = logging.getLogger()
        root_logger.setLevel(getattr(logging, log_config.level.upper()))
        
        # Clear existing handlers
        root_logger.handlers.clear()
        
        # Console handler
        console_handler = logging.StreamHandler()
        console_handler.setFormatter(formatter)
        root_logger.addHandler(console_handler)
        
        # File handler (if configured)
        if log_config.file_path:
            from logging.handlers import RotatingFileHandler
            file_handler = RotatingFileHandler(
                log_config.file_path,
                maxBytes=log_config.max_file_size,
                backupCount=log_config.backup_count
            )
            file_handler.setFormatter(formatter)
            root_logger.addHandler(file_handler)

def create_sample_config():
    """Create a sample configuration file"""
    sample_config = {
        'database': {
            'region': 'us-east-1',
            'table_prefix': 'vuln-scanner',
            'endpoint_url': None
        },
        'bitbucket': {
            'workspace': 'your-workspace',
            'username': 'your-username',
            'app_password': 'your-app-password',
            'base_url': 'https://api.bitbucket.org/2.0'
        },
        'cve_sources': {
            'nvd_api_key': 'your-nvd-api-key',
            'snyk_api_token': 'your-snyk-token',
            'oss_index_username': 'your-oss-username',
            'oss_index_token': 'your-oss-token'
        },
        'scanning': {
            'schedule': '0 2 * * *',
            'max_concurrent_scans': 5,
            'scan_timeout': 300,
            'retry_attempts': 3,
            'retry_delay': 60
        },
        'alerts': {
            'enabled': True,
            'critical_threshold': 1,
            'email_recipients': ['security@company.com'],
            'slack_webhook_url': 'https://hooks.slack.com/...',
            'teams_webhook_url': ''
        },
        'api': {
            'host': '0.0.0.0',
            'port': 8080,
            'cors_origins': ['*'],
            'rate_limit_enabled': True,
            'rate_limit_requests': 100
        },
        'logging': {
            'level': 'INFO',
            'format': '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            'file_path': 'logs/vulnerability_scanner.log',
            'max_file_size': 10485760,
            'backup_count': 5
        },
        'environment': 'development',
        'debug': False
    }
    
    with open('config.sample.yaml', 'w') as f:
        yaml.dump(sample_config, f, default_flow_style=False, indent=2)
    
    print("Sample configuration created: config.sample.yaml")
    print("Copy to config.yaml and update with your settings")

if __name__ == "__main__":
    create_sample_config()