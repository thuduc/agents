#!/usr/bin/env python3
"""
Multi-CVE database scanner for vulnerability detection
"""

import asyncio
import logging
from datetime import datetime
from typing import List
import aiohttp

from ..core.models import Config, Vulnerability, SeverityLevel


class MultiCVEScanner:
    """Integrates multiple CVE databases for comprehensive vulnerability scanning"""
    
    def __init__(self, config: Config):
        self.config = config
        self.session = None
        
    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self
        
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def scan_package(self, package_name: str, version: str) -> List[Vulnerability]:
        """Scan a package against all configured CVE databases"""
        vulnerabilities = []
        
        # Scan with multiple sources in parallel
        tasks = []
        if self.config.nvd_api_key:
            tasks.append(self._scan_nvd(package_name, version))
        if self.config.oss_index_token:
            tasks.append(self._scan_oss_index(package_name, version))
        if self.config.snyk_api_token:
            tasks.append(self._scan_snyk(package_name, version))
            
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        for result in results:
            if isinstance(result, list):
                vulnerabilities.extend(result)
            elif isinstance(result, Exception):
                logging.error(f"CVE scan error: {result}")
                
        return vulnerabilities
    
    async def _scan_nvd(self, package_name: str, version: str) -> List[Vulnerability]:
        """Scan using NIST NVD API"""
        url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        headers = {"apiKey": self.config.nvd_api_key} if self.config.nvd_api_key else {}
        
        params = {
            "keywordSearch": f"python {package_name}",
            "resultsPerPage": 100
        }
        
        vulnerabilities = []
        
        try:
            async with self.session.get(url, headers=headers, params=params) as response:
                if response.status == 200:
                    data = await response.json()
                    
                    for cve in data.get('vulnerabilities', []):
                        cve_data = cve.get('cve', {})
                        
                        # Extract CVSS score
                        metrics = cve_data.get('metrics', {})
                        cvss_score = 0.0
                        if 'cvssMetricV31' in metrics:
                            cvss_score = metrics['cvssMetricV31'][0]['cvssData']['baseScore']
                        elif 'cvssMetricV3' in metrics:
                            cvss_score = metrics['cvssMetricV3'][0]['cvssData']['baseScore']
                        
                        # Determine severity
                        severity = self._get_severity_from_cvss(cvss_score)
                        
                        vulnerability = Vulnerability(
                            cve_id=cve_data.get('id', ''),
                            package_name=package_name,
                            affected_version=version,
                            severity=severity,
                            description=cve_data.get('descriptions', [{}])[0].get('value', ''),
                            cvss_score=cvss_score,
                            published_date=datetime.fromisoformat(cve_data.get('published', '').replace('Z', '+00:00')),
                            references=[ref.get('url', '') for ref in cve_data.get('references', [])],
                            source='NVD'
                        )
                        vulnerabilities.append(vulnerability)
                        
        except Exception as e:
            logging.error(f"NVD scan failed for {package_name}: {e}")
            
        return vulnerabilities
    
    async def _scan_oss_index(self, package_name: str, version: str) -> List[Vulnerability]:
        """Scan using Sonatype OSS Index"""
        url = "https://ossindex.sonatype.org/api/v3/component-report"
        
        coordinates = f"pkg:pypi/{package_name}@{version}"
        data = {"coordinates": [coordinates]}
        
        auth = None
        if self.config.oss_index_username and self.config.oss_index_token:
            auth = aiohttp.BasicAuth(self.config.oss_index_username, self.config.oss_index_token)
        
        vulnerabilities = []
        
        try:
            async with self.session.post(url, json=data, auth=auth) as response:
                if response.status == 200:
                    results = await response.json()
                    
                    for result in results:
                        for vuln in result.get('vulnerabilities', []):
                            vulnerability = Vulnerability(
                                cve_id=vuln.get('cve', vuln.get('id', '')),
                                package_name=package_name,
                                affected_version=version,
                                severity=SeverityLevel.HIGH if vuln.get('cvssScore', 0.0) >= 7.0 else SeverityLevel.MEDIUM,
                                description=vuln.get('description', ''),
                                cvss_score=vuln.get('cvssScore', 0.0),
                                published_date=datetime.now(),
                                references=[vuln.get('reference', '')],
                                source='OSS_INDEX'
                            )
                            vulnerabilities.append(vulnerability)
                            
        except Exception as e:
            logging.error(f"OSS Index scan failed for {package_name}: {e}")
            
        return vulnerabilities
    
    async def _scan_snyk(self, package_name: str, version: str) -> List[Vulnerability]:
        """Scan using Snyk API"""
        url = f"https://api.snyk.io/v1/test/pip/{package_name}/{version}"
        headers = {"Authorization": f"token {self.config.snyk_api_token}"}
        
        vulnerabilities = []
        
        try:
            async with self.session.get(url, headers=headers) as response:
                if response.status == 200:
                    data = await response.json()
                    
                    for issue in data.get('issues', {}).get('vulnerabilities', []):
                        severity_map = {
                            'critical': SeverityLevel.CRITICAL,
                            'high': SeverityLevel.HIGH,
                            'medium': SeverityLevel.MEDIUM,
                            'low': SeverityLevel.LOW
                        }
                        
                        vulnerability = Vulnerability(
                            cve_id=issue.get('identifiers', {}).get('CVE', [''])[0],
                            package_name=package_name,
                            affected_version=version,
                            severity=severity_map.get(issue.get('severity', 'low'), SeverityLevel.LOW),
                            description=issue.get('title', ''),
                            cvss_score=issue.get('cvssScore', 0.0),
                            published_date=datetime.fromisoformat(issue.get('publicationTime', '').replace('Z', '+00:00')),
                            references=[issue.get('url', '')],
                            source='SNYK'
                        )
                        vulnerabilities.append(vulnerability)
                        
        except Exception as e:
            logging.error(f"Snyk scan failed for {package_name}: {e}")
            
        return vulnerabilities
    
    def _get_severity_from_cvss(self, cvss_score: float) -> SeverityLevel:
        """Convert CVSS score to severity level"""
        if cvss_score >= 9.0:
            return SeverityLevel.CRITICAL
        elif cvss_score >= 7.0:
            return SeverityLevel.HIGH
        elif cvss_score >= 4.0:
            return SeverityLevel.MEDIUM
        elif cvss_score > 0.0:
            return SeverityLevel.LOW
        else:
            return SeverityLevel.INFO