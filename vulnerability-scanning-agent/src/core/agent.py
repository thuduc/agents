#!/usr/bin/env python3
"""
Main vulnerability scanning agent orchestrator
"""

import asyncio
import logging
import time
from typing import Dict, List
from datetime import datetime

from .models import Config, Vulnerability, ScanResult
from ..scanning.bitbucket_scanner import BitBucketScanner
from ..scanning.cve_scanner import MultiCVEScanner
from ..storage.dynamodb_storage import DynamoDBStorage
from ..notifications.reporter import VulnerabilityReporter


class VulnerabilityScanningAgent:
    """Main orchestrator for the vulnerability scanning system"""
    
    def __init__(self, config: Config):
        self.config = config
        self.storage = DynamoDBStorage(config)
        self.reporter = VulnerabilityReporter(self.storage)
        
    async def initialize(self):
        """Initialize the scanning agent"""
        await self.storage.initialize_tables()
        logging.info("Vulnerability scanning agent initialized")
    
    async def scan_all_repositories(self) -> Dict[str, List[Vulnerability]]:
        """Perform a comprehensive scan of all repositories"""
        results = {}
        
        async with BitBucketScanner(self.config) as bb_scanner:
            repositories = await bb_scanner.get_repositories()
            
            semaphore = asyncio.Semaphore(self.config.max_concurrent_scans)
            tasks = []
            
            for repo in repositories:
                task = self._scan_repository_with_semaphore(
                    semaphore, bb_scanner, repo['name']
                )
                tasks.append(task)
            
            scan_results = await asyncio.gather(*tasks, return_exceptions=True)
            
            for i, result in enumerate(scan_results):
                repo_name = repositories[i]['name']
                if isinstance(result, list):
                    results[repo_name] = result
                    
                    # Store results
                    scan_id = f"scan_{int(time.time())}_{repo_name}"
                    await self.storage.store_scan_results(scan_id, repo_name, result)
                    
                    # Send alerts for critical vulnerabilities
                    await self.reporter.send_critical_alerts(result)
                else:
                    logging.error(f"Failed to scan {repo_name}: {result}")
                    results[repo_name] = []
        
        return results
    
    async def _scan_repository_with_semaphore(
        self, 
        semaphore: asyncio.Semaphore, 
        bb_scanner: BitBucketScanner,
        repo_name: str
    ) -> List[Vulnerability]:
        """Scan a single repository with concurrency control"""
        async with semaphore:
            return await self._scan_repository(bb_scanner, repo_name)
    
    async def _scan_repository(self, bb_scanner: BitBucketScanner, repo_name: str) -> List[Vulnerability]:
        """Scan a single repository for vulnerabilities"""
        vulnerabilities = []
        
        try:
            dependency_files = await bb_scanner.find_dependency_files(repo_name)
            
            async with MultiCVEScanner(self.config) as cve_scanner:
                for dep_file in dependency_files:
                    packages = self._parse_dependencies(dep_file['content'])
                    
                    for package_name, version in packages:
                        package_vulnerabilities = await cve_scanner.scan_package(package_name, version)
                        vulnerabilities.extend(package_vulnerabilities)
                        
        except Exception as e:
            logging.error(f"Error scanning repository {repo_name}: {e}")
            
        return vulnerabilities
    
    def _parse_dependencies(self, content: str) -> List[tuple[str, str]]:
        """Parse dependencies from requirements.txt or setup.py content"""
        packages = []
        
        for line in content.split('\n'):
            line = line.strip()
            if line and not line.startswith('#'):
                if '==' in line:
                    name, version = line.split('==', 1)
                    packages.append((name.strip(), version.strip()))
                elif '>=' in line:
                    name = line.split('>=')[0].strip()
                    packages.append((name, 'latest'))
                else:
                    packages.append((line, 'latest'))
                    
        return packages